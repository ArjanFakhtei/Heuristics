# -*- coding: utf-8 -*-
"""
Created on Tue Jan 30 00:09:19 2018

@author: Vlad
"""

####################################################################################################################


import random

class Tile(): 
    def __init__(self, ID, width, height):
        self.x = -20
        self.y = -20
        self.ID = ID
        self.width = width
        self.height = height
        self.color = "#" + ("%06x" % random.randint(0, 16777215))
        self.possiblePositions = []
        self.placed = False
        self.flipped = False
        self.marked = False
        
    def isMarked(self): return self.marked
    
    def getX(self): return self.x
    
    def getY(self): return self.y 
    
    def getID(self): return self.ID
    
    def getWidth(self): return self.width
    
    def getHeight(self): return self.height
    
    def getSurface(self): return (self.width * self.height)
    
    def getColor(self): return self.color
    
#    def __eq__(self, other): return self.args == other.args
    
    def compareTo(self, other): return self.getSurface() - other.getSurface()
    
    def flip(self): 
        self.width, self.height = self.height, self.width
#        self.flipped=True
        if self.flipped == False:
            self.flipped = True
        else: self.flipped = False
    
    def getFlipped(self): return self.flipped
    
    def setCoordinates(self, x, y): 
        self.x = x
        self.y = y
        
    def removeFirstPosition(self): self.possiblePositions.pop(0)
    
    def getPossiblePositions(self): return self.possiblePositions
    
    def addPossiblePosition(self, x, y, flipped): self.possiblePositions.append(((x, y), flipped))
    
    def placeThisTile(self): self.placed = True
    
    def removeThisTile(self): self.placed = False
    
    def getPlaced(self): return self.placed
    
    def sortPositions(self): self.possiblePositions = sorted(self.possiblePositions, key=lambda position: position[1], reverse=True)
    
    
    ################################################################################################################
    
from Tkinter import *

class FieldFrame(object):
    MARGINLEFT = 25
    MARGINTOP = 25
    
    def __init__(self, field, scale):
        self.SCALE = scale
        self.field = field
        
        self.root = Tk()
        
        self.frame = Frame(self.root, width=1024, height=768, colormap="new")
        self.frame.pack(fill=BOTH, expand=1)
        #self.frame.repaint(self.field)
        
        self.label = Label(self.frame, text="Heuristics VU - Tiling!")
        self.label.pack(fill=X, expand=1)
        
        self.canvas = Canvas(self.frame,
                             bg="white",
                             width=self.field.getWidth() * self.SCALE + 1,
                             height=self.field.getHeight() * self.SCALE + 1,
                             cursor="PLUS")
        self.canvas.pack()
        
        self.canvas.bind("<Button-1>", self.processMouseEvent)
        self.canvas.focus_set()
        
    def setField(self, field):
        for tile in field.getTiles():
            tile = tile[0]
            #print(tile.getID())
            self.canvas.create_rectangle(tile.getX() * self.SCALE + 2,
                                         tile.getY() * self.SCALE + 2,
                                         (tile.getX() + tile.getWidth()) * self.SCALE + 2,
                                         (tile.getY() + tile.getHeight()) * self.SCALE + 2,
                                         fill=tile.getColor())
        self.canvas.pack()
        self.root.update()

    def repaint(self, field):
        self.canvas.delete("all")
        self.setField(field)
        self.root.after(10)
            
    def processMouseEvent(self, event):
        coordinates = ((event.x / self.SCALE), ",", (event.y / self.SCALE))
        self.canvas.create_text(event.x, event.y, text=coordinates)
        
####################################################################################################################



import numpy
#from Tile import Tile


class Field(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.tileset = []
        self.placedID = []
        self.isolatedArea = []
        self.visitedCoordinates = []
        self.visitedCoordinates = []

        self.field = [[0 for y in range(self.height)] for x in range(self.width)]

    def __copy__(self):
        return type(self)

    def getHeight(self):
        return self.height

    def getWidth(self):
        return self.width

    def getTile(self, index):
        return self.tileset[index]

    def getTiles(self):
        return self.tileset

    def addTile(self, tile, placed, surface):
        self.tileset.append([tile, placed, surface])
    
    def sortTileset(self):
#        print(self.tileset[1])
#        print(self.tileset[2])
#        print(self.tileset[0])
#        self.tileset = sorted(self.tileset, key=lambda x:(x[1],-x[2], x[0]))
        self.tileset = sorted(self.tileset, key=lambda tile: (tile[1],-tile[2]))        

    def getNumberOfTiles(self):
        return len(self.tileset)
    
    def getLastPlacedID(self): return self.placedID[-1]
    
    def removeLastPlacedID(self): self.placedID.pop()

    def placeTile(self, tile, x, y):
        if not (x >= self.width or y >= self.height):
            for i in range(tile.getWidth()):
                for j in range(tile.getHeight()):
                    self.field[x + i][y + j] = tile.getID()
            tile.setCoordinates(x, y)
            tile.placeThisTile()
            self.placedID.append(tile.getID())
            for instance in self.tileset:
                if instance[0] == tile:
                    self.tileset.remove(instance)
                    instance[1] = True
                    self.tileset.append(instance)
            return True
        return False

    def inRange(self, tile, x, y):
        
        
        if ((self.width - x >= tile.getWidth()) and (self.height - y >= tile.getHeight())):
            for i in range(tile.getWidth()):
                for j in range(tile.getHeight()):
                    if (self.isOccupied(x + i, y + j)):
                        return False
            return True
        return False

    def removeTile(self, tile):
        for i in range(tile.getWidth()):
            for j in range(tile.getHeight()):
                self.field[tile.getX() + i][tile.getY() + j] = 0
        for instance in self.tileset:
            if instance[0] == tile:
                self.tileset.remove(instance)
                instance[1] = False
                self.tileset.append(instance)
        self.placedID.remove(tile.getID())
        tile.setCoordinates(-20, -20)

    def getTileAt(self, x, y):
        return self.field[x][y]

    def isOccupied(self, x, y):
        return self.field[x][y] != 0

    def solved(self):
        for x in range(self.getWidth()):
            for y in range(self.getHeight()):
                if not self.isOccupied(x, y): return False
        return True

    def getField(self):
        return self.field

    def isEmpty(self, x, y):
        return self.field[x][y] == 0
    
    def getFilledPercentage(self):
        filledCoordinates = 0 
        totalCoordinates = 0
        for x in range(self.width):
            for y in range(self.height):
                totalCoordinates += 1
                if self.isOccupied(x, y):
                    filledCoordinates += 1
        return (float(filledCoordinates)/totalCoordinates * 100)
    
    def clearIsolatedArea(self): self.isolatedArea = []
    
    def clearVisitedCoordinates(self): self.visitedCoordinates = []
    
    def getVisitedCoordinates(self): return self.visitedCoordinates
    
    def IsolatedWhitespace(self, i, j):
        self.isolatedArea.append((i, j))
        self.visitedCoordinates.append((i, j))
        if len(self.isolatedArea) > 10:
            return
        for (i, j) in self.isolatedArea:
            if i-1 >= 0:
                if self.field[i-1][j]==0 and (i-1, j) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i-1,j)
            if i+1 < self.width:
                if self.field[i+1][j]==0 and (i+1, j) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i+1,j)
            if j+1 < self.height:
                if self.field[i][j+1]==0 and (i, j+1) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i,j+1)
            if j-1 >= 0:
                if self.field[i][j-1]==0 and (i, j-1) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i,j-1)
                    
    def getIsolatedArea(self): return self.isolatedArea
    
    #################################################################################################################
    
import os, sys, time, numpy
sys.setrecursionlimit(200000)
#os.chdir("../Configurations")

#from tilingObjects.Version1Tile import Tile
#from tiling.FieldFrame import FieldFrame
#from tiling.Version1Field import Field

class Assignment():
    
    def __init__(self):
#        self.CONFIGURATION = configuration
        self.steps = 0
        self.maxFilledPercentage = 0
        self.maxfilledStep = 0
        self.visited_tiles = list()
        self.path = list()
        self.solution=0
        
        maxDepth = 14
#        i = 1
        i = 0
#        for line in open("C:/Users/Vlad/Desktop/tilings/15-0-0.tiles", 'r'):
#            print(line)
##            if i == 0:
#            n1, n2 = (int(s) for s in line.split())             
#            print(n1,n2)
#        with open("C:/Users/Vlad/Desktop/tilings/15-0-0.tiles") as fileIn:
#        for line in open("H:/Desktop/tilings/15-0-0.tiles"):
#            line = line.split(' ')
##            print(line[0])
#            if i == 0:
#                
#                print(line)
#                width = line[1]
#                height = line[3]
#                scale = line[5]
#                print(height,width,scale)
#                i=i+1
#                self.field = Field(int(width), int(height))
#                self.frame = FieldFrame(self.field, int(scale))
#            else:
#                times = line[0]
#                line = line[2].split('x')
#                width = line[0]
#                height = line[1]
#                print(times, height, width)
#                for i in range(int(times)):
#                    tile = Tile(i, int(width), int(height))
#                    self.field.addTile(tile, False, tile.getSurface())
#                    i=i+1
#                firstNum, secondNum = [int(s) for s in str.split(' ') if s.isdigit()]
#                print(firstNum, secondNum)
#            if idx==0:
#                line=line.split(' ')
#                print(line[])
#        for idx, each_line in enumerate(open(self.CONFIGURATION, 'r')):
#            if idx == 0:
#                width, height, scale = map(int, each_line.strip().split("\t"))
#                self.field = Field(width, height)
#            else: 
#                frequency, width, height = map(int, each_line.strip().split("\t"))
#                for idx in range(frequency):
#                    tile = Tile(i, width, height)
#                    self.field.addTile(tile, False, tile.getSurface())
#                    i += 1 #tileID
        tile1 = Tile(1,2,2)                                                         #    ID,HEIGHT,WIDTH
        tile2 = Tile(2,3,3)
        tile3 = Tile(3,3,3)
        tile4 = Tile(4,3,3)
        tile5 = Tile(5,3,3)
        tile6 = Tile(6,3,3)
        tile7 = Tile(7,3,3)
        tile8 = Tile(8,3,3)
#        tile9 = Tile(9,5,5)
        tile10 = Tile(10,5,5)
        tile11 = Tile(11,5,5)
        tile12 = Tile(12,5,5)
        tile13 = Tile(13,7,7)
        tile14 = Tile(14,7,7)
        tile15 = Tile(15,7,7)
        
#        tile1 = Tile(1,2,2)                                                         #    ID,HEIGHT,WIDTH
#        tile2 = Tile(2,2,2)
#        tile3 = Tile(3,2,2)
#        tile4 = Tile(4,3,3)
#        tile5 = Tile(5,1,1)
#        tile6 = Tile(6,1,1)
#        tile7 = Tile(7,1,1)
#        tile8 = Tile(8,1,1)                                                    #    ID,HEIGH

#        self.field = Field(5,5)
        self.field = Field(17,17)
#
        self.field.addTile(tile1,False,tile1.getSurface())

        self.field.addTile(tile2,False,tile2.getSurface())
        self.field.addTile(tile3,False,tile3.getSurface())
        self.field.addTile(tile4,False,tile4.getSurface())
        self.field.addTile(tile5,False,tile5.getSurface())
        self.field.addTile(tile6,False,tile6.getSurface())
        self.field.addTile(tile7,False,tile7.getSurface())
        self.field.addTile(tile8,False,tile8.getSurface())
#        self.field.addTile(tile9,False,tile9.getSurface(),False)
        self.field.addTile(tile10,False,tile10.getSurface())
        self.field.addTile(tile11,False,tile11.getSurface())
        self.field.addTile(tile12,False,tile12.getSurface())
        self.field.addTile(tile13,False,tile13.getSurface())
        self.field.addTile(tile14,False,tile14.getSurface())
        self.field.addTile(tile15,False,tile15.getSurface())
#
        self.frame = FieldFrame(self.field, 30)
#        self.frame.repaint(self.field)
#        self.frame.root.mainloop()
#        self.recursivePlacing()
        depth=0
#        self.checkWhiteSpace()
        self.solve(self.visited_tiles, depth, 14)
       # print(self.visited_tiles)
        self.frame.root.mainloop()
#        print(self.field.field[19][0])                    ##################USEFUL##################################
#        print(self.field.tileset[1])

     
    def getInsertion(self):
            for y in range(self.field.getHeight()):
                for x in range(self.field.getWidth()):
                    if self.field.field[x][y] == 0:
                        return (x,y)
        
    def solve(self, visited_tiles, depth, maxDepth):
#        
#        time_start = time.clock()
#        
        print(self.visited_tiles)

        if self.field.solved():
            
            print("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            print("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            print("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            print(self.solution)
            self.solution=self.solution+1
            print(depth)
            print(maxDepth)
#            sys.exit()
        
    
        if depth<maxDepth:
            
            self.field.sortTileset()            
#            instance = self.field.getTiles()[0]
#            tile = instance[0]
            
            
#            self.field.sortTileset()
            
#            for y in range(self.field.getHeight()):
#                for x in range(self.field.getWidth()):
            
            for tile in self.field.tileset:
#                        self.field.sortTileset()
#                print (tile[0].getID())                
                #instance = self.field.tileset[tile]
#                tile=instance[tile]
                        if tile[1] == False:
#                            if tile[0].getFlipped() == True:
#                                tile[0].flip()
                            
                            cord = self.getInsertion()
                            if self.field.inRange(tile[0],cord[0],cord[1]):
                                
#                                self.checkWhiteSpace()
#                                print(isolatedAreas)
#                                self.isolatedWhiteSpace()
#                                self.visited_tiles.append(tile[0].getID())
                                self.field.placeTile(tile[0], cord[0], cord[1])  
                                self.frame.repaint(self.field)
                                self.visited_tiles.append(tile[0].getID())
#                                x=x+tile[0].getWidth()
#                                y=y+tile[0].getHeight()
                                
                                self.solve(self.visited_tiles, depth+1, maxDepth)
#                                if tile[0].getHeight()!=tile[0].getWidth():
#                                    tile[0].flip()
                                self.visited_tiles.pop()
                                self.field.removeTile(tile[0])
                                
#                                self.checkWhiteSpace()
#                                print(isolatedAreas)
#                                self.isolatedWhiteSpace()
#                                self.visited_tiles.append(tile[0].getID())
#                            elif self.field.inRange(tile[0].flip(),cord[0],cord[1]): 
#                                print(tile[0].getWidth())
#                                print(tile[0].getHeight())
##                                tile[0].flip()
#                                print(tile[0].getWidth())
#                                print(tile[0].getHeight())
#                                self.field.inRange(tile[0], cord[0], cord[1])
#                                self.field.placeTile(tile[0], cord[0], cord[1])  
#                                self.frame.repaint(self.field)
#                                self.visited_tiles.append(tile[0].getID())
##                                x=x+tile[0].getWidth()
##                                y=y+tile[0].getHeight()
#                                self.solve(self.visited_tiles, depth+1, maxDepth)
#                                self.visited_tiles.pop()
#                                self.field.removeTile(tile[0])
#                        
                               # counter=counter-1
                                    
#                                self.visited_tiles.pop()
                           

Assignment()


#for i in range(5):
#    for j in range(5):
#        CONFIGURATION = "15-%d-%d.txt" %(i,j)
#        start_time = time.time()  
