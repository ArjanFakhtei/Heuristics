# -*- coding: utf-8 -*-
"""
Created on Fri Jan 12 11:28:58 2018

@author: Arjan
"""
class Tile():
    
    def __init__(self, width, height):
        self.x = 0
        self.y = 0
        self.width = width
        self.height = height
        self.possibleLocations = []
        self.flipped = False
        self.placed = False
        
    def getX(self):
        return self.x
    
    def getY(self):
        return self.y
    
    def getWidth(self):
        return self.width
    
    def getHeight(self):
        return self.height
    
    def getSize(self):
        return (self.x*self.getHeight)
    
    def compareTo(self, otherTile):
        return (self.getSize-otherTile.getSize)
    
    def flip(self):
        self.height = self.width
        self.width = self.height
        
    def isFlipped(self):
        return self.flipped
    
    def changeLocation(self, x, y):
        self.x = x
        self.y = y
        
    def isPlaced(self):
        return self.placed
    
    def placeTile(self):
        self.placed = True
        
    def removeTile(self):
        self.placed = False
        
    def removeFirstLocation(self):
        self.possibleLocations.pop[0]
        
    def getPossibleLocations(self):
        return self.possibleLocations
    
    def addPossibleLocation(self, x, y, flipped):
        self.possibleLocations.append(((x, y), flipped))
    
    def sortLocations(self):
        self.possibleLocations = sorted(self.possibleLocations, key = lambda position: position[1], reverse = True)
        
    
    
    
        
root = Tk()
        
frame = Frame(root, width=10, height=10, colormap="new")
frame.pack(fill=BOTH, expand=1)
        
label = Label(frame, text="Heuristics 2018")
label.pack(fill=X, expand=1)
        
canvas = Canvas(frame,
                             bg="white",
                             width=1700,
                             height=1700,
                             cursor="PLUS")
#tile1 = canvas.create_rectangle(1700-canvas.canvasx(0),canvas.canvasy(0),1700-canvas.canvasx(300),canvas.canvasy(400),fill='black')       #x0, y0, x1, y1
tile1 = canvas.create_rectangle(0,0,100,150,fill='black')       #x0, y0, x1, y1
tile2 = canvas.create_rectangle(100,0,200,100,fill='red')       #x0, y0, x1, y1
tile3 = canvas.create_rectangle(200,0,300,80,fill='green')       #x0, y0, x1, y1

canvas.pack()

#root.mainloop()


        
        
class Field(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.tileset = []
        self.placedID = []

        self.field = [[0 for y in range(self.height)] for x in range(self.width)]

    def __copy__(self):
        return type(self)

    def getHeight(self):
        return self.height

    def getWidth(self):
        return self.width

    def getTile(self, index):
        return self.tileset[index]

    def getTiles(self):
        return self.tileset

    def addTile(self, tile, placed):
        self.tileset.append([tile, placed])
    
    def sortTileset(self):
        self.tileset = sorted(self.tileset, key=lambda x:(x[1],-x[2], x[0]))

    def getNumberOfTiles(self):
        return len(self.tileset)
    
    def getLastPlacedID(self): return self.placedID[-1]
    
    def removeLastPlacedID(self): self.placedID.pop()

    def placeTile(self, tile, x, y):
        if not (x >= self.width or y >= self.height):
            for i in range(tile.getWidth()):
                for j in range(tile.getHeight()):
                    self.field[x + i][y + j] = tile.getID()
            tile.setCoordinates(x, y)
            tile.placeThisTile()
            self.placedID.append(tile.getID())
            for instance in self.tileset:
                if instance[0] == tile:
                    self.tileset.remove(instance)
                    instance[1] = True
                    self.tileset.append(instance)
            return True
        return False

    def inRange(self, tile, x, y):
        if ((self.width - x >= tile.getWidth()) and (self.height - y >= tile.getHeight())):
            for i in range(tile.getWidth()):
                for j in range(tile.getHeight()):
                    if (self.isOccupied(x + i, y + j)):
                        return False
            return True
        return False

    def removeTile(self, tile):
        for i in range(tile.getWidth()):
            for j in range(tile.getHeight()):
                self.field[tile.getX() + i][tile.getY() + j] = 0
        for instance in self.tileset:
            if instance[0] == tile:
                self.tileset.remove(instance)
                instance[1] = False
                self.tileset.append(instance)
        self.placedID.remove(tile.getID())
        tile.setCoordinates(0, 0)

    def getTileAt(self, x, y):
        return self.field[x][y]

    def isOccupied(self, x, y):
        return self.field[x][y] != 0

    def solved(self):
        for x in range(self.getWidth()):
            for y in range(self.getHeight()):
                if not self.isOccupied(x, y): return False
        return True

    def getField(self):
        return self.field

    def isEmpty(self, x, y):
        return self.field[x][y] == 0
    
    def getFilledPercentage(self):
        filledCoordinates = 0 
        totalCoordinates = 0
        for x in range(self.width):
            for y in range(self.height):
                totalCoordinates += 1
                if self.isOccupied(x, y):
                    filledCoordinates += 1
        return (float(filledCoordinates)/totalCoordinates * 100)
        
        
        

data = open('H:/Desktop/tiles1.txt')
print(data.read())

field = Field(1700, 1700)

for line in open('H:/Desktop/tiles1.txt', 'r'):
        for i in range(int(line[0])):
            lines = line.split('x')
            tileWidth = lines[1]
            tileHeight = lines[2]
#            print(tileWidth)
#            print(tileHeight)
            tile = Tile(tileWidth, tileHeight)
#            print(tile)
            field.addTile(tile, False)

print(field.tileset[11])

            
            
            
            
            
            
            
            
            
