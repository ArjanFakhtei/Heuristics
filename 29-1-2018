####################################################################################################################


import random

class Tile(): 
    def __init__(self, ID, width, height):
        self.x = -20
        self.y = -20
        self.ID = ID
        self.width = width
        self.height = height
        self.color = "#" + ("%06x" % random.randint(0, 16777215))
        self.possiblePositions = []
        self.placed = False
        self.flipped = False
        self.marked = False
        
    def isMarked(self): return self.marked
    
    def getX(self): return self.x
    
    def getY(self): return self.y 
    
    def getID(self): return self.ID
    
    def getWidth(self): return self.width
    
    def getHeight(self): return self.height
    
    def getSurface(self): return (self.width * self.height)
    
    def getColor(self): return self.color
    
#    def __eq__(self, other): return self.args == other.args
    
    def compareTo(self, other): return self.getSurface() - other.getSurface()
    
    def flip(self): 
        self.width, self.height = self.height, self.width
        if self.flipped == False:
            self.flipped = True
        else: self.flipped = False
    
    def getFlipped(self): return self.flipped
    
    def setCoordinates(self, x, y): 
        self.x = x
        self.y = y
        
    def removeFirstPosition(self): self.possiblePositions.pop(0)
    
    def getPossiblePositions(self): return self.possiblePositions
    
    def addPossiblePosition(self, x, y, flipped): self.possiblePositions.append(((x, y), flipped))
    
    def placeThisTile(self): self.placed = True
    
    def removeThisTile(self): self.placed = False
    
    def getPlaced(self): return self.placed
    
    def sortPositions(self): self.possiblePositions = sorted(self.possiblePositions, key=lambda position: position[1], reverse=True)
    
    
    ################################################################################################################
    
from tkinter import *

class FieldFrame(object):
    MARGINLEFT = 25
    MARGINTOP = 25
    
    def __init__(self, field, scale):
        self.SCALE = scale
        self.field = field
        
        self.root = Tk()
        
        self.frame = Frame(self.root, width=1024, height=768, colormap="new")
        self.frame.pack(fill=BOTH, expand=1)
        #self.frame.repaint(self.field)
        
        self.label = Label(self.frame, text="Heuristics VU - Tiling!")
        self.label.pack(fill=X, expand=1)
        
        self.canvas = Canvas(self.frame,
                             bg="white",
                             width=self.field.getWidth() * self.SCALE + 1,
                             height=self.field.getHeight() * self.SCALE + 1,
                             cursor="PLUS")
        self.canvas.pack()
        
        self.canvas.bind("<Button-1>", self.processMouseEvent)
        self.canvas.focus_set()
        
    def setField(self, field):
        for tile in field.getTiles():
            tile = tile[0]
            #print(tile.getID())
            self.canvas.create_rectangle(tile.getX() * self.SCALE + 2,
                                         tile.getY() * self.SCALE + 2,
                                         (tile.getX() + tile.getWidth()) * self.SCALE + 2,
                                         (tile.getY() + tile.getHeight()) * self.SCALE + 2,
                                         fill=tile.getColor())
        self.canvas.pack()
        self.root.update()

    def repaint(self, field):
        self.canvas.delete("all")
        self.setField(field)
        self.root.after(1)
            
    def processMouseEvent(self, event):
        coordinates = ((event.x / self.SCALE), ",", (event.y / self.SCALE))
        self.canvas.create_text(event.x, event.y, text=coordinates)
        
####################################################################################################################



import numpy
#from Tile import Tile


class Field(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.tileset = []
        self.placedID = []
        self.isolatedArea = []
        self.visitedCoordinates = []
        self.visitedCoordinates = []

        self.field = [[0 for y in range(self.height)] for x in range(self.width)]

    def __copy__(self):
        return type(self)

    def getHeight(self):
        return self.height

    def getWidth(self):
        return self.width

    def getTile(self, index):
        return self.tileset[index]

    def getTiles(self):
        return self.tileset

    def addTile(self, tile, placed, score,checked):
        self.tileset.append([tile, placed, score,checked])
    
    def sortTileset(self):
#        print(self.tileset[1])
#        print(self.tileset[2])
#        print(self.tileset[0])
#        self.tileset = sorted(self.tileset, key=lambda x:(x[1],-x[2], x[0]))
        self.tileset = sorted(self.tileset, key=lambda tile: (tile[1],-tile[2]))        

    def getNumberOfTiles(self):
        return len(self.tileset)
    
    def getLastPlacedID(self): return self.placedID[-1]
    
    def removeLastPlacedID(self): self.placedID.pop()

    def placeTile(self, tile, x, y):
        if not (x >= self.width or y >= self.height):
            for i in range(tile.getWidth()):
                for j in range(tile.getHeight()):
                    self.field[x + i][y + j] = tile.getID()
            tile.setCoordinates(x, y)
            tile.placeThisTile()
            self.placedID.append(tile.getID())
            for instance in self.tileset:
                if instance[0] == tile:
                    self.tileset.remove(instance)
                    instance[1] = True
                    self.tileset.append(instance)
            return True
        return False

    def inRange(self, tile, x, y):
        if ((self.width - x >= tile.getWidth()) and (self.height - y >= tile.getHeight())):
            for i in range(tile.getWidth()):
                for j in range(tile.getHeight()):
                    if (self.isOccupied(x + i, y + j)):
                        return False
            return True
        return False

    def removeTile(self, tile):
        for i in range(tile.getWidth()):
            for j in range(tile.getHeight()):
                self.field[tile.getX() + i][tile.getY() + j] = 0
        for instance in self.tileset:
            if instance[0] == tile:
                self.tileset.remove(instance)
                instance[1] = False
                self.tileset.append(instance)
        self.placedID.remove(tile.getID())
        tile.setCoordinates(-20, -20)

    def getTileAt(self, x, y):
        return self.field[x][y]

    def isOccupied(self, x, y):
        return self.field[x][y] != 0

    def solved(self):
        for x in range(self.getWidth()):
            for y in range(self.getHeight()):
                if not self.isOccupied(x, y): return False
        return True

    def getField(self):
        return self.field

    def isEmpty(self, x, y):
        return self.field[x][y] == 0
    
    def getFilledPercentage(self):
        filledCoordinates = 0 
        totalCoordinates = 0
        for x in range(self.width):
            for y in range(self.height):
                totalCoordinates += 1
                if self.isOccupied(x, y):
                    filledCoordinates += 1
        return (float(filledCoordinates)/totalCoordinates * 100)
    
    def clearIsolatedArea(self): self.isolatedArea = []
    
    def clearVisitedCoordinates(self): self.visitedCoordinates = []
    
    def getVisitedCoordinates(self): return self.visitedCoordinates
    
    def IsolatedWhitespace(self, i, j):
        self.isolatedArea.append((i, j))
        self.visitedCoordinates.append((i, j))
        if len(self.isolatedArea) > 10:
            return
        for (i, j) in self.isolatedArea:
            if i-1 >= 0:
                if self.field[i-1][j]==0 and (i-1, j) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i-1,j)
            if i+1 < self.width:
                if self.field[i+1][j]==0 and (i+1, j) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i+1,j)
            if j+1 < self.height:
                if self.field[i][j+1]==0 and (i, j+1) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i,j+1)
            if j-1 >= 0:
                if self.field[i][j-1]==0 and (i, j-1) not in self.visitedCoordinates:
                    self.IsolatedWhitespace(i,j-1)
                    
    def getIsolatedArea(self): return self.isolatedArea
    
    #################################################################################################################
    
import os, sys, time, numpy
sys.setrecursionlimit(200000)
#os.chdir("../Configurations")

#from tilingObjects.Version1Tile import Tile
#from tiling.FieldFrame import FieldFrame
#from tiling.Version1Field import Field

class Assignment():
    
    def __init__(self):
#        self.CONFIGURATION = configuration
        self.steps = 0
        self.maxFilledPercentage = 0
        self.maxfilledStep = 0
        self.visited_tiles = list()
        self.path = list()
        
        
#        i = 1
#        for idx, each_line in enumerate(open(self.CONFIGURATION, 'r')):
#            if idx == 0:
#                width, height, scale = map(int, each_line.strip().split("\t"))
#                self.field = Field(width, height)
#            else: 
#                frequency, width, height = map(int, each_line.strip().split("\t"))
#                for idx in range(frequency):
#                    tile = Tile(i, width, height)
#                    self.field.addTile(tile, False, tile.getSurface())
#                    i += 1 #tileID
#        tile1 = Tile(1,2,2)                                                         #    ID,HEIGHT,WIDTH
#        tile2 = Tile(2,3,3)
#        tile3 = Tile(3,3,3)
#        tile4 = Tile(4,3,3)
#        tile5 = Tile(5,3,3)
#        tile6 = Tile(6,3,3)
#        tile7 = Tile(7,3,3)
#        tile8 = Tile(8,3,3)
##        tile9 = Tile(9,5,5)
#        tile10 = Tile(10,5,5)
#        tile11 = Tile(11,5,5)
#        tile12 = Tile(12,5,5)
#        tile13 = Tile(13,7,7)
#        tile14 = Tile(14,7,7)
#        tile15 = Tile(15,7,7)
        
        tile1 = Tile(1,2,2)                                                         #    ID,HEIGHT,WIDTH
        tile2 = Tile(2,2,2)
        tile3 = Tile(3,2,2)
        tile4 = Tile(4,3,3)
        tile5 = Tile(5,1,1)
        tile6 = Tile(6,1,1)
        tile7 = Tile(7,1,1)
        tile8 = Tile(8,1,1)                                                    #    ID,HEIGH

        self.field = Field(5,5)
        self.field.addTile(tile1,False,tile1.getSurface(),False)

        self.field.addTile(tile2,False,tile2.getSurface(),False)
        self.field.addTile(tile3,False,tile3.getSurface(),False)
        self.field.addTile(tile4,False,tile4.getSurface(),False)
        self.field.addTile(tile5,False,tile5.getSurface(),False)
        self.field.addTile(tile6,False,tile6.getSurface(),False)
        self.field.addTile(tile7,False,tile7.getSurface(),False)
        self.field.addTile(tile8,False,tile8.getSurface(),False)
#        self.field.addTile(tile9,False,tile9.getSurface(),False)
#        self.field.addTile(tile10,False,tile10.getSurface(),False)
#        self.field.addTile(tile11,False,tile11.getSurface(),False)
#        self.field.addTile(tile12,False,tile12.getSurface(),False)
#        self.field.addTile(tile13,False,tile13.getSurface(),False)
#        self.field.addTile(tile14,False,tile14.getSurface(),False)
#        self.field.addTile(tile15,False,tile15.getSurface(),False)

        self.frame = FieldFrame(self.field, 40)
        self.frame.repaint(self.field)
#        self.frame.root.mainloop()
#        self.recursivePlacing()
        depth=0
#        self.checkWhiteSpace()
        self.solve(self.visited_tiles, depth, 8)
       # print(self.visited_tiles)
        self.frame.root.mainloop()
#        print(self.field.field[19][0])                    ##################USEFUL##################################
#        print(self.field.tileset[1])

    def isolatedWhiteSpace(self):
        #first check if the field has already been filled for more than the threshold percentage
#        occupied = 0
#        fieldsurface = 0
#        for x in range(self.field.getWidth()):
#            for y in range(self.field.getHeight()):
#                fieldsurface += 1
#                if self.field.isOccupied(x, y):
#                    occupied += 1
#        percentage = (float(occupied)/fieldsurface * 100)
#        if percentage >= 90:
#            return True
        
        #determine all the isolated areas
        isolatedAreas = []
        for i in range(self.field.getWidth()):
            for j in range(self.field.getHeight()):
                if self.field.isEmpty(i, j) and (i, j) not in self.field.getVisitedCoordinates():
                    self.field.IsolatedWhitespace(i, j)
                    isolatedAreas += [self.field.getIsolatedArea()]
                    self.field.clearIsolatedArea()
        self.field.clearVisitedCoordinates()
        
        #try to fill the isolated areas, except for the biggest area
        if len(isolatedAreas) > 1:
            isolatedAreas.sort(key = len)
            isolatedAreas.pop()
            for whitespace in isolatedAreas:
                filledTiles = self.fillIsolatedSurface(whitespace)
                if filledTiles != 'Succeed': #delete filled tiles from placed tiles / backtrack those tiles
                    for i in range(filledTiles):
                        self.field.sortTileset()
                        tile = self.field.getTiles()[-1]
                        tile[0].removeThisTile()
                        self.field.removeTile(tile[0])
                        self.frame.repaint(self.field)
                    del isolatedAreas
                    return False #if the whitespace cannot be filled
        del isolatedAreas
        return True #if there is no isolated whitespace except for the big one or if all whitespaces are filled

    def fillIsolatedSurface(self, isolatedArea):
        filledTiles = 0
        self.field.sortTileset()
        for instance in self.field.getTiles():
            tile = instance[0]
            if not instance[1]: #als de tile al geplaatst is in de whitespace, dan niet nog een keer plaatsen
                for coordinate in isolatedArea:
                    x = coordinate[0]
                    y = coordinate[1]
                    if self.field.inRange(tile, x, y):
                        if self.field.placeTile(tile, x, y):
                            self.frame.repaint(self.field)
                            filledTiles += 1
                            for i in range(tile.getWidth()):
                                for j in range(tile.getHeight()):
                                    if (x + i, y + j) in isolatedArea:
                                        isolatedArea.remove((x + i, y + j)) #if placed, remove coordinates from isolated area
                            break
                    elif (tile.getWidth() != tile.getHeight()):
                        tile.flip()
                        if self.field.inRange(tile, x, y):
                            if self.field.placeTile(tile, x, y):
                                self.frame.repaint(self.field)
                                filledTiles += 1
                                for i in range(tile.getWidth()):
                                    for j in range(tile.getHeight()):
                                        if (x + i, y + j) in isolatedArea:
                                            isolatedArea.remove((x + i, y + j)) #if placed, remove coordinates from isolated area
                                break
                        else: tile.flip()
        if isolatedArea != []: #if the area could not be filled completely
            return filledTiles #return number of tiles, to backtrack them
        else: return 'Succeed'
        
    def checkWhiteSpace(self):
        
##        s = '''1 1 1
##            1 0 1
##            1 0 1'''
#    
#        nrows = self.field.getHeight()
#        ncols = self.field.getWidth()
#        skip_not = 0
#        area_max = (0, [])
#        
#        a = numpy.array(self.field.field)
##        a[0,0] = 1
##        a[0,1] = 1
##        a[0,2] = 1
##        a[0,3] = 1
##        a[0,4] = 1
#        a[3,0] = 1
#        a[3,1] = 1
#        a[3,2] = 1
#        a[3,3] = 1
#        a[3,4] = 1
#        
#        
#        print(a)
##        a = numpy.matrix[[1,2,3],[1,0,1],[1,0,1]]#numpy.fromstring(s, dtype=int, sep=' ').reshape(nrows, ncols)
#        w = numpy.zeros(dtype=int, shape=a.shape)
#        h = numpy.zeros(dtype=int, shape=a.shape)
#        for r in range(nrows):
#            for c in range(ncols):
#                if not a[r][c] == skip_not:
#                    continue
#                if r == 0:
#                    h[r][c] = 1
#                else:
#                    h[r][c] = h[r-1][c]+1
#                if c == 0:
#                    w[r][c] = 1
#                else:
#                    w[r][c] = w[r][c-1]+1
#                minw = w[r][c]
#                for dh in range(h[r][c]):
#                    minw = min(minw, w[r-dh][c])
#                    area = (dh+1)*minw
#                    if area > area_max[0]:
#                        area_max = (area, [(r, c, dh+1, minw)])
#        print(w)
#        print(h)
#        print('area', area_max[0])
#        for t in area_max[1]:
#            print('coord and shape', t)
#        print(area_max[1])
#        whiteWidth = 0
#        whiteHeight = 0
#        lis = []
        whiteWidth = 0
#        for i in range(self.field.getWidth()):
#            if 
#            print(i)
#            if self.field.field[]
#            for j in range(self.field.getWidth()):
##                print(i,j)
#                if self.field.field[i][j] == 0:
#                    whiteWidth = whiteWidth + 1
#                    whiteHeight = whiteHeight + 1
#                    while not self.field.field[i][j] == 0:
#                        whiteWidth = whiteWidth + 1
#                    while not self.field.field[i][j] == 0:
#                        whiteHeight = whiteHeight + 1
#                    lis.append([whiteWidth, whiteHeight])
#        print(lis)
#                if self.field.isEmpty(i, j) and (i, j) not in self.field.getVisitedCoordinates():
#                    self.field.IsolatedWhitespace(i, j)
#                    isolatedAreas += [self.field.getIsolatedArea()]
#                    self.field.clearIsolatedArea()
#        self.field.clearVisitedCoordinates()    
        
                
        
    def solve(self, visited_tiles, depth, maxDepth):
#        
#        time_start = time.clock()
#        
        print(self.visited_tiles)

        if self.field.solved():
            print("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            print("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
            print("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
#            sys.exit()
        
    
        if depth<maxDepth:
            
#            self.field.sortTileset()            
#            instance = self.field.getTiles()[0]
#            tile = instance[0]
            
            self.field.sortTileset()
            for tile in self.field.tileset:
               # self.field.sortTileset()
#                print (tile[0].getID())                
                #instance = self.field.tileset[tile]
#                tile=instance[tile]
                if tile[1] == False:
                    for y in range(self.field.getHeight()):
                        for x in range(self.field.getWidth()): #determine available positions for the tile
                            if  self.field.inRange(tile[0], x, y):
#                                self.checkWhiteSpace()
#                                print(isolatedAreas)
#                                self.isolatedWhiteSpace()
#                                self.visited_tiles.append(tile[0].getID())
                                self.field.placeTile(tile[0], x, y)  
                                self.frame.repaint(self.field)
                                self.visited_tiles.append(tile[0].getID())
                                #[3]==True
                               # counter=counter-1
                                self.solve(self.visited_tiles, depth+1, maxDepth)
                                self.visited_tiles.pop()
                                self.field.removeTile(tile[0])
#                                self.visited_tiles.pop()
                           




#for i in range(5):
#    for j in range(5):
#        CONFIGURATION = "15-%d-%d.txt" %(i,j)
#        start_time = time.time()  

          
Assignment()
        
